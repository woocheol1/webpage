<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍스트 도구 - 웹 도구 모음집</title>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        /* === 기존 스타일 === */
        .tools-tabs {
            display: flex;
            flex-wrap: wrap;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
    
        .tab-button {
            padding: 10px 15px;
            background-color: #f5f5f5;
            border: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
    
        .tab-button:hover {
            background-color: #e0e0e0;
        }
    
        .tab-button.active {
            background-color: #3498db;
            color: white;
        }
    
        .tab-content {
            display: none;
        }
    
        .tab-content.active {
            display: block;
        }
    
        /* === 텍스트 포맷터 섹션 관련 스타일 === */
    
        /* 기본적인 폼 요소 그룹에 하단 여백을 추가 */
        /* textarea를 감싸는 div 등에도 적용되어 요소 간 분리 */
        .form-group {
            margin-bottom: 15px;
        }
    
        /* textarea 기본 스타일 유지 및 .form-group 여백 적용으로 간격 확보 */
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: 'Courier New', monospace; /* 코드/텍스트 편집에 적합한 글꼴 */
            font-size: 14px;
            box-sizing: border-box; /* padding과 border가 width에 포함되도록 */
        }
    
        /* fieldset 형태의 form-group 스타일 (각 줄에 추가할 내용 선택 부분) */
        fieldset.form-group {
            padding: 10px 15px; /* fieldset 내부 여백 */
            border: 1px solid #ccc; /* 경계선 추가 */
            border-radius: 4px; /* 모서리 둥글게 */
            margin-bottom: 15px; /* fieldset 아래 여백 */
        }
    
        /* fieldset의 legend (제목) 스타일 */
        fieldset.form-group legend {
            font-weight: bold; /* 글자 두껍게 */
            padding: 0 5px; /* legend 좌우 여백 */
            /* background-color: #fff; */ /* 배경색 (테두리와 겹치는 부분 처리 시 사용) */
            margin-bottom: 10px; /* 제목 아래 여백 */
            display: block; /* 블록 요소로 만들어 아래 내용과 분리 */
        }
    
        /* 라디오 버튼 각 항목별 여백 */
        .radio-group-item {
            margin-bottom: 8px; /* 라디오 버튼 항목 간 여백 */
        }
        /* 마지막 라디오 버튼 항목 하단 여백 제거 */
        .radio-group-item:last-child {
            margin-bottom: 0;
        }
    
        /* 사용자 지정 문자열 입력 필드 그룹의 상단 여백 */
        #customPrefixInputGroup {
            margin-top: 10px; /* 라디오 버튼 그룹과의 상단 여백 */
            /* JavaScript에서 display: none; 상태를 제어함 */
        }
    
        /* 비활성화된 입력 필드 스타일 */
        #lineSeparatorInput:disabled {
            background-color: #e9e9e9; /* 회색 배경 */
            color: #777; /* 흐린 글자색 */
            cursor: not-allowed; /* 마우스 커서 변경 */
        }
    
    
        /* 액션 버튼 컨테이너 스타일 (기존 스타일 유지 및 간격 약간 조정) */
        .action-buttons {
            margin-top: 20px; /* 위쪽 여백 (기존 15px에서 약간 조정) */
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* 버튼 간 간격 */
        }
    
        /* 액션 버튼 기본 스타일 (기존 스타일 유지) */
        .action-button {
            padding: 8px 15px;
            /* margin-right: 5px; */ /* gap으로 대체되거나 함께 사용될 수 있음 */
            border: none; /* 기존 버튼 스타일과 일치 */
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            /* 기본 배경색과 글자색 (Primary 버튼 스타일) */
            background-color: #3498db;
            color: white;
        }
    
        /* 액션 버튼 호버 효과 (기존 스타일 유지) */
        .action-button:hover {
            background-color: #2980b9; /* Primary 버튼 호버 */
        }
    
        /* 보조 버튼 스타일 (기존 스타일 유지) */
        .action-button.secondary {
            background-color: #95a5a6;
            color: white; /* 보조 버튼 글자색 추가 (기존에 없었으면) */
        }
    
        /* 보조 버튼 호버 효과 (기존 스타일 유지) */
        .action-button.secondary:hover {
            background-color: #7f8c8d;
        }
    
    
        /* 결과 미리보기 영역 스타일 (기존 스타일 유지 및 일부 추가) */
        .result-preview {
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            margin-top: 15px;
            min-height: 50px;
            border: 1px solid #ddd;
            white-space: pre-wrap; /* 원본 텍스트 줄바꿈 유지 */
            word-wrap: break-word; /* 긴 단어 줄바꿈 추가 */
            font-family: 'Courier New', monospace; /* monospace 글꼴 유지 */
            overflow: auto; /* 내용이 넘치면 스크롤바 표시 추가 */
        }
    
    
        /* === 기존 다른 스타일 === */
    
        /* 통계 컨테이너 스타일 (텍스트 포맷터와는 직접 관련 없음) */
        .stats-container {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
    
        .stat-box {
            background-color: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 120px;
            text-align: center;
        }
        .stat-box h4 {
            margin: 0;
            color: #3498db;
            font-size: 14px;
        }
    
        .stat-box p {
            margin: 10px 0 0 0;
            font-size: 18px;
            font-weight: bold;
        }
    
        /* 다크 모드 관련 스타일 (기존 스타일) */
        .dark-mode .tab-button {
            background-color: #34495e;
            color: #ecf0f1;
        }
    
        .dark-mode .tab-button.active {
            background-color: #2980b9;
        }
    
        .dark-mode .tab-button:hover {
            background-color: #2c3e50;
        }
    
        /* 다크 모드 토글 버튼 스타일 (기존 스타일) */
        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff; /* 본문 색상에 따라 조정 필요할 수 있음 */
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 10; /* 다른 요소 위에 표시 */
        }
    
        /* Diff 뷰어 관련 스타일 (기존 스타일) */
        .diff-line {
            padding: 5px;
            margin: 2px 0;
        }
    
        .diff-line.identical {
            background-color: #f0f0f0;
        }
    
        .diff-line.different {
            background-color: #ffeded;
            border-left: 3px solid #e74c3c;
        }
    
        .diff-old {
            color: #c0392b;
        }
    
        .diff-new {
            color: #27ae60;
        }
    
        /* 미디어 쿼리 (기존 스타일) */
        @media (max-width: 768px) {
            .tools-tabs {
                flex-direction: column;
            }
    
            .tab-button {
                margin-bottom: 5px;
                border-radius: 4px;
            }
        }
    
    </style>
</head>
<body>
    <header>
        <h1>텍스트 도구</h1>
        <p>텍스트 변환, 분석, 포맷팅 도구 모음</p>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()">🌓</button>
    </header>

    <div class="container">
        <button class="back-button" onclick="window.location.href='../index.html'">← 메인으로 돌아가기</button>

        <div class="tool-interface">
            <div class="tools-tabs">
                <button class="tab-button active" data-tab="text-stats">텍스트 통계</button>
                <button class="tab-button" data-tab="case-converter">대소문자 변환</button>
                <button class="tab-button" data-tab="text-formatter">포맷 변환</button>
                <button class="tab-button" data-tab="text-diff">텍스트 비교</button>
                <button class="tab-button" data-tab="remove-spaces">공백 제거</button>
                <button class="tab-button" data-tab="line-sorter">줄 정렬</button>
            </div>

            <div id="text-stats" class="tab-content active">
                <h3>텍스트 통계 분석</h3>
                <p>텍스트의 문자, 단어, 줄 수 등을 분석합니다.</p>

                <div class="form-group">
                    <label for="statsInputText">분석할 텍스트:</label>
                    <textarea id="statsInputText" placeholder="분석할 텍스트를 입력하세요..." onkeyup="analyzeText()"></textarea>
                </div>

                <div class="stats-container">
                    <div class="stat-box">
                        <h4>문자 수</h4>
                        <p id="charCount">0</p>
                    </div>
                    <div class="stat-box">
                        <h4>단어 수</h4>
                        <p id="wordCount">0</p>
                    </div>
                    <div class="stat-box">
                        <h4>줄 수</h4>
                        <p id="lineCount">0</p>
                    </div>
                    <div class="stat-box">
                        <h4>문단 수</h4>
                        <p id="paragraphCount">0</p>
                    </div>
                    <div class="stat-box">
                        <h4>공백 포함 문자 수</h4>
                        <p id="charCountWithSpaces">0</p>
                    </div>
                    <div class="stat-box">
                        <h4>읽기 시간(분)</h4>
                        <p id="readingTime">0</p>
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="action-button" onclick="analyzeText()">분석 새로고침</button>
                    <button class="action-button secondary" onclick="clearText('statsInputText'); analyzeText();">지우기</button>
                </div>
            </div>
            <div id="case-converter" class="tab-content">
                <h3>대소문자 변환</h3>
                <p>텍스트의 대소문자를 변환하세요.</p>

                <div class="form-group">
                    <label for="caseInputText">변환할 텍스트:</label>
                    <textarea id="caseInputText" placeholder="변환할 텍스트를 입력하세요..."></textarea>
                </div>

                <div class="action-buttons">
                    <button class="action-button" onclick="convertCase('upper')">대문자로 변환</button>
                    <button class="action-button" onclick="convertCase('lower')">소문자로 변환</button>
                    <button class="action-button" onclick="convertCase('title')">제목 형식으로 변환</button>
                    <button class="action-button" onclick="convertCase('sentence')">문장 형식으로 변환</button>
                    <button class="action-button" onclick="convertCase('toggle')">대소문자 반전</button>
                    <button class="action-button secondary" onclick="clearText('caseInputText')">지우기</button>
                    <button class="action-button secondary" onclick="copyConvertedText()">결과 복사</button>
                </div>

                <div id="case-result" class="result-preview"></div>
            </div>

            <div id="text-formatter" class="tab-content">
                <h3>텍스트 포맷 변환</h3>
                <p>텍스트를 다양한 형식으로 변환합니다. (지원 기능: 한 줄로 합치기, 각 줄에 순차 번호 또는 사용자 지정 접두사 추가)</p>
            
                <div class="form-group">
                    <label for="formatInputText">변환할 텍스트:</label>
                    <textarea id="formatInputText" placeholder="변환할 텍스트를 입력하세요..."></textarea>
                </div>
            
                <fieldset class="form-group">
                    <legend>각 줄에 추가할 내용 선택:</legend>
                    <div class="radio-group-item"> <input type="radio" id="modeNumbered" name="prefixMode" value="numbered" checked>
                        <label for="modeNumbered">순차 번호 (1., 2., 3., ...)</label>
                    </div>
                    <div class="radio-group-item">
                        <input type="radio" id="modeCustomPrefix" name="prefixMode" value="customPrefix">
                        <label for="modeCustomPrefix">사용자 지정 문자열</label>
                    </div>
                </fieldset>
            
                <div id="customPrefixInputGroup" class="form-group">
                     <label for="lineSeparatorInput">사용할 문자열 입력:</label>
                     <input type="text" id="lineSeparatorInput" value=". " placeholder="예: . , => , : ">
                </div>
            
            
                <div class="action-buttons">
                    <button class="action-button" onclick="formatText('singleLine')">한 줄로 합치기</button>
                    <button class="action-button" onclick="formatText('addPrefix', document.getElementById('lineSeparatorInput').value)">각 줄에 선택된 내용 추가</button>
            
                    <button class="action-button secondary" onclick="clearText('formatInputText')">지우기</button>
                    <button class="action-button secondary" onclick="copyFormattedText()">결과 복사</button>
                </div>
            
                <div id="format-result" class="result-preview"></div>
            </div>

            <div id="text-diff" class="tab-content">
                <h3>텍스트 비교</h3>
                <p>두 텍스트 간의 차이점을 확인합니다.</p>

                <div class="form-group">
                    <label for="diffText1">첫 번째 텍스트:</label>
                    <textarea id="diffText1" placeholder="첫 번째 텍스트를 입력하세요..."></textarea>
                </div>

                <div class="form-group">
                    <label for="diffText2">두 번째 텍스트:</label>
                    <textarea id="diffText2" placeholder="두 번째 텍스트를 입력하세요..."></textarea>
                </div>

                <div class="action-buttons">
                    <button class="action-button" onclick="compareTexts()">텍스트 비교하기</button>
                    <button class="action-button secondary" onclick="clearDiffTexts()">모두 지우기</button>
                </div>

                <div id="diff-result" class="result-preview"></div>
            </div>

            <div id="remove-spaces" class="tab-content">
                <h3>공백 제거 도구</h3>
                <p>텍스트에서 다양한 유형의 공백을 제거합니다.</p>

                <div class="form-group">
                    <label for="spacesInputText">처리할 텍스트:</label>
                    <textarea id="spacesInputText" placeholder="공백을 제거할 텍스트를 입력하세요..."></textarea>
                </div>

                <div class="action-buttons">
                    <button class="action-button" onclick="removeSpaces('all')">모든 공백 제거</button>
                    <button class="action-button" onclick="removeSpaces('leading')">앞쪽 공백 제거</button>
                    <button class="action-button" onclick="removeSpaces('trailing')">뒤쪽 공백 제거</button>
                    <button class="action-button" onclick="removeSpaces('duplicate')">중복 공백 제거</button>
                    <button class="action-button secondary" onclick="clearText('spacesInputText')">지우기</button>
                    <button class="action-button secondary" onclick="copySpacesResult()">결과 복사</button>
                </div>

                <div id="spaces-result" class="result-preview"></div>
            </div>
            <div id="line-sorter" class="tab-content">
                <h3>줄 정렬 도구</h3>
                <p>텍스트의 각 줄을 정렬합니다.</p>

                <div class="form-group">
                    <label for="sortInputText">정렬할 텍스트:</label>
                    <textarea id="sortInputText" placeholder="줄별로 정렬할 텍스트를 입력하세요..."></textarea>
                </div>

                <div class="action-buttons">
                    <button class="action-button" onclick="sortLines('asc')">오름차순 정렬</button>
                    <button class="action-button" onclick="sortLines('desc')">내림차순 정렬</button>
                    <button class="action-button" onclick="sortLines('length')">길이순 정렬</button>
                    <button class="action-button" onclick="sortLines('random')">무작위 정렬</button>
                    <button class="action-button" onclick="sortLines('reverse')">줄 역순 배치</button>
                    <button class="action-button" onclick="sortLines('unique')">중복 줄 제거</button>
                    <button class="action-button secondary" onclick="clearText('sortInputText')">지우기</button>
                    <button class="action-button secondary" onclick="copySortResult()">결과 복사</button>
                </div>

                <div id="sort-result" class="result-preview"></div>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 웹 도구 모음집 | 개인 프로젝트</p>
    </footer>

    <script src="../js/common.js"></script>
    <script>
        // 페이지 로드 시 실행
        document.addEventListener('DOMContentLoaded', function() {
            console.log('텍스트 도구 페이지 로드됨');

            // 탭 전환 이벤트 설정
            const tabButtons = document.querySelectorAll('.tab-button');

            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // 활성 탭 버튼 변경
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');

                    // 모든 탭 컨텐츠 숨기기
                    const tabContents = document.querySelectorAll('.tab-content');
                    tabContents.forEach(content => content.classList.remove('active'));

                    // 선택한 탭 컨텐츠 표시
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');

                    console.log('탭 변경:', tabId);
                    logAction('텍스트 도구 탭 변경', { tab: tabId });
                });
            });

            // 통계 탭이 로드되면 기본 통계 계산 (초기 텍스트가 있다면)
             analyzeText();
        });

        // 대소문자 변환 함수
        function convertCase(type) {
            try {
                const inputText = document.getElementById('caseInputText').value;
                const resultElement = document.getElementById('case-result');
                let result = '';

                switch(type) {
                    case 'upper':
                        result = inputText.toUpperCase();
                        break;
                    case 'lower':
                        result = inputText.toLowerCase();
                        break;
                    case 'title':
                        // 한글 문장 부호 뒤 첫 글자 등도 대문자로 변환하도록 로직 수정
                        result = inputText.toLowerCase()
                           .replace(/(?:^|\.\s*|\?\s*|!\s*)\w/g, match => match.toUpperCase()) // 문장 시작/끝점 뒤
                           .replace(/([\s-])\w/g, match => match.toUpperCase()); // 공백이나 하이픈 뒤 (영문 위주)
                        // 한글 단어 시작 처리 보강 (단어 경계에서 첫 글자) - 복잡해지므로 기본 형태 유지 또는 더 정교한 라이브러리 사용 고려
                        // 현재는 기본적인 영문 위주 타이틀 케이스와 한글 문장 시작 대문자 정도 지원
                        break;
                    case 'sentence':
                        result = inputText.toLowerCase()
                            // 문장의 시작 또는 마침표/물음표/느낌표 뒤의 첫 글자를 대문자로 변환
                            .replace(/(^\s*\w|[.!?]\s*\w)/g, match =>
                                match.toUpperCase()
                            );
                        break;
                    case 'toggle':
                        result = inputText.split('').map(char => {
                            // 영문 대소문자만 토글
                            if (char >= 'a' && char <= 'z') {
                                return char.toUpperCase();
                            } else if (char >= 'A' && char <= 'Z') {
                                return char.toLowerCase();
                            } else {
                                return char; // 영문이 아니면 그대로 유지
                            }
                        }).join('');
                        break;
                    default:
                        result = inputText;
                }

                resultElement.textContent = result;
                console.log('대소문자 변환 완료:', type);
                logAction('대소문자 변환', { type, length: inputText.length });
            } catch (error) {
                console.error('대소문자 변환 오류:', error);
                showNotification('변환 중 오류가 발생했습니다.', 'error');
            }
        }

        // 변환된 텍스트 복사
        function copyConvertedText() {
            const resultText = document.getElementById('case-result').textContent;
            copyToClipboard(resultText);
        }

        // 텍스트 지우기 함수
        function clearText(elementId) {
            document.getElementById(elementId).value = '';

            // 결과 영역 지우기
            if (elementId === 'caseInputText') {
                document.getElementById('case-result').textContent = '';
            } else if (elementId === 'formatInputText') {
                document.getElementById('format-result').textContent = '';
            } else if (elementId === 'spacesInputText') {
                document.getElementById('spaces-result').textContent = '';
            } else if (elementId === 'sortInputText') {
                 document.getElementById('sort-result').textContent = '';
             }

            console.log('텍스트 지움:', elementId);
            logAction('텍스트 지우기', { element: elementId });
        }

        // 텍스트 분석 함수
        function analyzeText() {
            try {
                const text = document.getElementById('statsInputText').value;

                // 공백 제외 문자 수
                const charCount = text.replace(/\s/g, '').length;
                document.getElementById('charCount').textContent = charCount;

                // 공백 포함 문자 수
                const charCountWithSpaces = text.length;
                document.getElementById('charCountWithSpaces').textContent = charCountWithSpaces;

                // 단어 수
                // \s+는 하나 이상의 공백(띄어쓰기, 탭, 줄바꿈 등)을 의미
                // trim()을 사용하여 앞뒤 공백 제거 후 split
                const wordCount = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
                document.getElementById('wordCount').textContent = wordCount;

                // 줄 수
                const lineCount = text === '' ? 0 : text.split(/\r\n|\r|\n/).length; // 다양한 줄바꿈 문자 처리
                document.getElementById('lineCount').textContent = lineCount;

                // 문단 수
                // 하나 이상의 빈 줄(\n\s*\n)로 구분되는 문단 계산
                const paragraphCount = text.trim() === '' ? 0 : text.trim().split(/\n\s*\n+/).length; // 하나 이상의 빈 줄
                document.getElementById('paragraphCount').textContent = paragraphCount;

                //---------------
                // 읽기 시간 (분 초) - 평균 읽기 속도 기준 조정
                // 목표 2분 10초를 위해 계산된 값 (대략 118~119 단어/분)
                const wordsPerMinute = 118; // 이 값을 조정하여 원하는 시간에 가깝게 설정

                const secondsPerMinute = 60;

                // 총 읽는 시간(초) 계산 (소수점 반올림)
                const totalSeconds = Math.round((wordCount / wordsPerMinute) * secondsPerMinute);

                // 분과 남은 초 계산
                const minutes = Math.floor(totalSeconds / secondsPerMinute);
                const seconds = totalSeconds % secondsPerMinute;

                // 00분 00초 형식으로 포맷팅
                const formattedMinutes = minutes.toString().padStart(2, '0');
                const formattedSeconds = seconds.toString().padStart(2, '0');

                // 결과 업데이트
                document.getElementById('readingTime').textContent = `${formattedMinutes}분 ${formattedSeconds}초`;
                //---------------

                console.log('텍스트 분석 완료', {
                    charCount, wordCount, lineCount,
                    paragraphCount, charCountWithSpaces, readingTime: `${formattedMinutes}분 ${formattedSeconds}초` // 로깅도 포맷팅된 시간으로
                });
                // logAction('텍스트 분석', { wordCount, readingTime: `${formattedMinutes}분 ${formattedSeconds}초` }); // 필요한 경우 분석 액션 로깅
            } catch (error) {
                console.error('텍스트 분석 오류:', error);
                // showNotification('분석 중 오류가 발생했습니다.', 'error'); // analyzeText는 onkeyup에서 자주 호출되므로 알림은 과할 수 있습니다.
            }
        }

        // 텍스트 포맷 변환 함수
        // separator 매개변수는 'customPrefix' 모드에서 각 줄 앞에 붙일 문자열을 지정합니다.
        // 'numbered' 모드에서는 무시됩니다.
        function formatText(type, separator = '. ') { // separator의 기본값은 customPrefix 모드의 기본값으로 사용
            try {
                const inputText = document.getElementById('formatInputText').value;
                const resultElement = document.getElementById('format-result');
                let result = '';

                switch(type) {
                    // 'singleLine' 기능 유지
                    case 'singleLine':
                        result = inputText.replace(/\r?\n/g, ' ').trim();
                        break;

                    // 'addLineNumbers' 타입을 'addPrefix'와 같은 이름으로 변경했다고 가정합니다.
                    // HTML 버튼의 onclick도 'addPrefix'로 변경해야 합니다.
                    case 'addPrefix':
                        // 어떤 모드가 선택되었는지 확인합니다.
                        const selectedMode = document.querySelector('input[name="prefixMode"]:checked').value;

                        if (selectedMode === 'numbered') {
                            // 순차 번호 모드: 1., 2., 3. ... 형식으로 번호와 . 공백을 붙입니다.
                            result = inputText.split('\n')
                                .map((line, index) => `${index + 1}. ${line}`) // 번호와 고정된 ". " 붙임
                                .join('\n');
                            console.log('포맷 변환 완료: addPrefix (모드: numbered)');

                        } else if (selectedMode === 'customPrefix') {
                            // 사용자 지정 문자열 모드: 입력받은 separator를 각 줄 앞에 붙입니다.
                            result = inputText.split('\n')
                                .map(line => `${separator}${line}`) // 입력받은 separator 붙임
                                .join('\n');
                            console.log(`포맷 변환 완료: addPrefix (모드: customPrefix, 접두사: "${separator}")`);

                        } else {
                            console.warn('알 수 없는 접두사 추가 모드:', selectedMode);
                            result = inputText; // 모드 오류 시 원본 반환
                        }
                        break;

                    default:
                        // 지원하지 않는 타입이 들어왔거나 기본 동작
                        console.warn('지원하지 않는 포맷 변환 타입입니다:', type);
                        result = inputText; // 원본 텍스트 반환
                }

                resultElement.textContent = result;

                // logAction 함수가 있다면 호출 (실제 구현에 맞게 수정 필요)
                if (typeof logAction === 'function') {
                    const logDetails = { type, length: inputText.length };
                    if (type === 'addPrefix') {
                        const selectedMode = document.querySelector('input[name="prefixMode"]:checked').value;
                        logDetails.mode = selectedMode;
                        if (selectedMode === 'customPrefix') {
                            logDetails.prefix = separator; // customPrefix 모드일 때만 접두사 정보 기록
                        }
                    }
                    logAction('텍스트 포맷 변환', logDetails);
                }


            } catch (error) {
                console.error('포맷 변환 오류:', error);
                // showNotification 함수가 정의되어 있다고 가정 (실제 구현에 맞게 수정 필요)
                if (typeof showNotification === 'function') {
                    showNotification('변환 중 오류가 발생했습니다.', 'error');
                } else {
                    alert('변환 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        // --- UI 상호작용 스크립트 (수정) ---
        // 페이지 로드 후 실행되도록 합니다.
        document.addEventListener('DOMContentLoaded', (event) => {
            const modeNumbered = document.getElementById('modeNumbered');
            const modeCustomPrefix = document.getElementById('modeCustomPrefix');
            const customPrefixInputGroup = document.getElementById('customPrefixInputGroup'); // 사용자 지정 문자열 입력 필드를 담는 div

            // 라디오 버튼 상태에 따라 사용자 지정 문자열 입력 필드 그룹을 보이기/숨기기/비활성화하는 함수
            function updateCustomPrefixInputVisibility() {
                if (modeCustomPrefix.checked) {
                    // '사용자 지정 문자열' 선택 시 입력 필드 그룹을 보이게 함
                    customPrefixInputGroup.style.display = 'block';
                    // 입력 필드도 활성화
                    document.getElementById('lineSeparatorInput').disabled = false;
                } else { // modeNumbered.checked === true
                    // '순차 번호' 선택 시 입력 필드 그룹을 숨김
                    customPrefixInputGroup.style.display = 'none';
                    // 입력 필드 비활성화 (숨겨져 있어도 접근 방지)
                    document.getElementById('lineSeparatorInput').disabled = true;
                }
            }

            // 라디오 버튼의 'change' 이벤트 리스너 추가
            modeNumbered.addEventListener('change', updateCustomPrefixInputVisibility);
            modeCustomPrefix.addEventListener('change', updateCustomPrefixInputVisibility);

            // 페이지 로드 시 초기 상태 설정 (기본값인 '순차 번호'가 선택되어 있으므로 입력 필드를 숨김)
            updateCustomPrefixInputVisibility();
        });

        // 주의: clearText, copyFormattedText, logAction, showNotification 함수는 이 코드 외부에 정의되어 있어야 합니다.
        // CSS에서 form-group 클래스나 radio-group-item 클래스에 적절한 margin, padding 스타일을 추가하면 더 보기 좋습니다.
        // 예: .form-group { margin-bottom: 15px; } .radio-group-item { margin-bottom: 5px; }

        // 텍스트 비교 함수
        function compareTexts() {
            try {
                const text1 = document.getElementById('diffText1').value;
                const text2 = document.getElementById('diffText2').value;
                const resultElement = document.getElementById('diff-result');

                // 간단한 차이점 계산
                const lines1 = text1.split('\n');
                const lines2 = text2.split('\n');

                let resultHTML = '';

                // 두 텍스트의 최대 줄 수만큼 반복
                const maxLines = Math.max(lines1.length, lines2.length);

                for (let i = 0; i < maxLines; i++) {
                    const line1 = lines1[i] || ''; // 해당 줄이 없으면 빈 문자열
                    const line2 = lines2[i] || '';

                    if (line1 === line2) {
                        // 줄이 동일한 경우
                        resultHTML += `<div class="diff-line identical">줄 ${i+1}: ${escapeHTML(line1)}</div>`;
                    } else {
                        // 줄이 다른 경우
                        resultHTML += `<div class="diff-line different">
                            <div class="diff-old">구본(${i+1}): ${escapeHTML(line1)}</div>
                            <div class="diff-new">신본(${i+1}): ${escapeHTML(line2)}</div>
                        </div>`;
                    }
                }

                 if (resultHTML === '') {
                    resultElement.textContent = '비교할 내용이 없습니다.';
                } else {
                    resultElement.innerHTML = resultHTML;
                }

                console.log('텍스트 비교 완료');
                logAction('텍스트 비교', {
                    text1Length: text1.length,
                    text2Length: text2.length
                });
            } catch (error) {
                console.error('텍스트 비교 오류:', error);
                showNotification('비교 중 오류가 발생했습니다.', 'error');
            }
        }
        
        // HTML 특수 문자 이스케이프 함수 (비교 결과 표시를 위해 추가)
        function escapeHTML(str) {
             return str.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&#039;');
        }


        // 텍스트 비교 입력 지우기
        function clearDiffTexts() {
            document.getElementById('diffText1').value = '';
            document.getElementById('diffText2').value = '';
            document.getElementById('diff-result').innerHTML = '';

            console.log('텍스트 비교 입력 지움');
            logAction('텍스트 비교 초기화');
        }

        // 공백 제거 함수
        function removeSpaces(type) {
            try {
                const inputText = document.getElementById('spacesInputText').value;
                const resultElement = document.getElementById('spaces-result');
                let result = '';

                // 빈 텍스트 처리
                if (!inputText) {
                    resultElement.textContent = '';
                    return;
                }

                switch(type) {
                    case 'all':
                        // 모든 공백 문자(\s는 띄어쓰기, 탭, 줄바꿈 등을 포함) 제거
                        result = inputText.replace(/\s/g, '');
                        break;
                    case 'leading':
                        // 각 줄의 시작 부분에 있는 공백 제거
                        result = inputText.split('\n')
                            .map(line => line.replace(/^\s+/, ''))
                            .join('\n');
                        break;
                    case 'trailing':
                        // 각 줄의 끝 부분에 있는 공백 제거
                        result = inputText.split('\n')
                            .map(line => line.replace(/\s+$/, ''))
                            .join('\n');
                        break;
                    case 'duplicate':
                        // 두 개 이상의 연속된 공백(띄어쓰기, 탭, 줄바꿈 등)을 하나의 띄어쓰기로 변경
                         result = inputText.replace(/\s+/g, ' ');
                        break;
                    default:
                        result = inputText;
                }

                 if (result === '') {
                    resultElement.textContent = ''; // 결과가 비어있으면 결과창도 비움
                } else {
                    resultElement.textContent = result;
                }

                console.log('공백 제거 완료:', type);
                logAction('공백 제거', { type, length: inputText.length });
            } catch (error) {
                console.error('공백 제거 오류:', error);
                showNotification('공백 제거 중 오류가 발생했습니다.', 'error');
            }
        }

        // 공백 제거 결과 복사
        function copySpacesResult() {
            const resultText = document.getElementById('spaces-result').textContent;
            copyToClipboard(resultText);
        }

        // 줄 정렬 함수
        function sortLines(type) {
            try {
                const inputText = document.getElementById('sortInputText').value;
                const resultElement = document.getElementById('sort-result');

                // 빈 텍스트 처리
                if (!inputText.trim()) {
                    resultElement.textContent = '';
                    return;
                }

                // 줄 단위로 분리 (빈 줄 포함)
                let lines = inputText.split('\n');

                switch(type) {
                    case 'asc':
                        lines.sort((a, b) => a.localeCompare(b, 'ko')); // 한글 정렬 지원
                        break;
                    case 'desc':
                        lines.sort((a, b) => b.localeCompare(a, 'ko')); // 한글 정렬 지원
                        break;
                    case 'length':
                        lines.sort((a, b) => a.length - b.length);
                        break;
                    case 'random':
                        lines.sort(() => Math.random() - 0.5);
                        break;
                    case 'reverse':
                        lines.reverse();
                        break;
                    case 'unique':
                         // Set을 이용하여 중복 제거, 다시 배열로 변환
                        lines = [...new Set(lines)];
                        break;
                    default:
                        break; // 지원하지 않는 타입은 그대로
                }

                resultElement.textContent = lines.join('\n');
                console.log('줄 정렬 완료:', type);
                logAction('줄 정렬', { type, lineCount: lines.length });
            } catch (error) {
                console.error('줄 정렬 오류:', error);
                showNotification('정렬 중 오류가 발생했습니다.', 'error');
            }
        }

        // 정렬 결과 복사
        function copySortResult() {
            const resultText = document.getElementById('sort-result').textContent;
            copyToClipboard(resultText);
        }

        // 공통 함수 (common.js에 있을 수 있지만 예시로 포함)
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
             // 로컬 스토리지에 다크 모드 상태 저장 (선택 사항)
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
            console.log('다크 모드 토글됨:', isDarkMode);
        }

         // 페이지 로드 시 다크 모드 상태 확인 (선택 사항)
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
        }

        // 클립보드에 텍스트를 복사하는 범용 함수
        // 이 함수는 사용자의 직접적인 상호작용 (예: 버튼 클릭) 내에서 호출되어야 보안 정책에 의해 허용됩니다.
        async function copyToClipboard(text) {
            try {
                // navigator.clipboard.writeText는 비동기 함수이므로 await 사용 (또는 .then())
                await navigator.clipboard.writeText(text);
                // 복사 성공 시 추가 작업 (선택 사항)
                // console.log('클립보드에 복사되었습니다.'); // copyFormattedText에서 알림 처리하므로 여기서는 불필요
            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                // 복사 실패 시 대체 방법 또는 오류 알림
                // alert('클립보드 복사 실패: ' + err); // copyFormattedText에서 알림 처리하므로 여기서는 불필요
                throw err; // 에러를 다시 던져서 copyFormattedText의 catch 블록에서 처리되게 함
            }
        }

        // 텍스트 포맷 변환기의 결과 복사 함수 (HTML 버튼에 연결된 함수)
        function copyFormattedText() {
            try {
                // 결과를 표시하는 요소의 ID는 'format-result'입니다.
                const resultElement = document.getElementById('format-result');
                const resultText = resultElement.textContent;

                // 클립보드 복사 함수 호출
                copyToClipboard(resultText);

                console.log('포맷 변환 결과 복사 완료');
                // showNotification 함수가 있다면 성공 메시지 표시
                if (typeof showNotification === 'function') {
                    showNotification('결과가 클립보드에 복사되었습니다.', 'success');
                }

            } catch (error) {
                console.error('결과 복사 오류:', error);
                // showNotification 함수가 있다면 오류 메시지 표시
                if (typeof showNotification === 'function') {
                    showNotification('결과 복사에 실패했습니다.', 'error');
                } else {
                    alert('결과 복사에 실패했습니다: ' + error.message);
                }
            }
        }
         // 간단한 알림 표시 함수 (예시, 실제 구현은 필요에 따라 다름)
         function showNotification(message, type) {
             console.log(`Notification (${type}): ${message}`);
             // 실제 사용자에게 보여주는 UI 구현 필요
             // 예: alert(message); 또는 페이지 내 알림 div 업데이트
         }

         // 액션 로깅 함수 (예시, 실제 구현은 필요에 따라 다름)
         function logAction(action, details = {}) {
             const timestamp = new Date().toISOString();
             console.log(`[ACTION] ${timestamp} - ${action}`, details);
             // 실제 로깅 서버나 분석 도구로 전송하는 로직 추가 가능
         }


    </script>
</body>
</html>